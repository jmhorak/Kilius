/**
 * Routing module for Kilius server
 *
 * Author: Jeff Horak
 * Date: 7/1/12
 */

var handler = require('modRequestHandler'),
    logging = require('modLogging'),
    blacklist = require('modBlackList'),
    url = require('url'),
    regexUserName = /^\/[a-zA-Z][0-9a-zA-Z_\-]{0,31}\/history\/?$/,
    regexPost = /^\/\+\/?$/,
    verbRouter;

/**
 * Handles routing of requests using the GET verb
 * @param reqData
 */
function handleGETRequest(reqData) {
  var path = reqData.path;

  if (path.indexOf('/+/') === 0) {
    handler.handleResolveURL(reqData);

  } else if (regexUserName.test(path)) {
    handler.handleStatsForUser(reqData);

  } else if (path === '/') {
    // Requesting the index page
    reqData.resource = 'index.html';
    handler.handleFetchResource(reqData);

  } else {
    // Requesting a specific resource
    reqData.resource = path;
    handler.handleFetchResource(reqData);
  }
}

/**
 * Handles routing of requests using the POST verb
 * @param reqData
 */
function handlePOSTRequest(reqData) {
  var data = [];

  if (regexPost.test(reqData.path) &&
      reqData.contentType === 'application/json') {

    reqData.request.on('data', function(chunk) {
      data.push(chunk);
    }).on('end',

        /**
         * Finished getting all the data, create the shortened URL
         */
        function() {
          var response = reqData.response;

          try {
            reqData.data = JSON.parse(data.join(''));
            handler.createShortenedURL(reqData);

          } catch(e) {
            logging.error({
              message: 'Exception thrown in getRequestData - bad client request',
              error:e.toString(),
              code: 400
            });

            response.writeHead(400); // 400 => Bad client request
            response.end();
          }
    });

  } else {
    handler.handleUnsupportedRequest(reqData);
  }
}

/**
 * Handles routing of unsupported requests
 * @param reqData
 */
function handleUnsupportedRequest(reqData) {
  handler.handleUnsupportedRequest(reqData);
}

/**
 * Handles a connection attempt from a blacklisted client
 * @param res
 */
function handleBlacklistConnectionAttempt(res) {
  // This is a blacklisted client connection, refuse to do anything
  res.writeHead(403); // Forbidden
  res.end();
}

/**
 * Makes routing to current and future verbs easy
 * @type {Object}
 */
verbRouter = {
  'GET': handleGETRequest,
  'POST': handlePOSTRequest,
  'PUT': handleUnsupportedRequest,
  'DELETE': handleUnsupportedRequest,
  'default': handleUnsupportedRequest
};

/**
 * Request routing entry point, examine the request and sends it to the correct handler
 * @param req - The request
 * @param res - The response
 */
exports.handleRequest = function(req, res) {

  var client = req.headers.host,
      reqURL,
      reqData,
      path,
      verb;

  // Is this client blacklisted?
  if (!blacklist.isClientBlacklisted(client)) {

    // Build the request data
    reqURL = url.parse(req.url);
    reqData = {
      url: reqURL,
      path: reqURL.pathname,
      host: client,
      ua: req.headers['user-agent'],
      contentType: req.headers['content-type'],
      modSince: new Date(req.headers['if-modified-since']),
      verb: req.method,
      response: res,
      request: req
    };
    path = reqData.path;
    verb = reqData.verb;

    // Log starting to handle request
    logging.log({
      client: client,
      message: 'Starting to process request'
    });

    // If the path starts with :, lop it off
    if (path.charAt(0) === ':') {
      path.substring(1);
    }

    // Push to routers for individual verbs
    verbRouter[verb] ? verbRouter[verb](reqData) : verbRouter['default'](reqData);

  } else {

    // Connection from a blacklisted client, log
    logging.log({
      client: client,
      message: 'Connection attempt from blacklisted client'
    });

    handleBlacklistConnectionAttempt(res);

  }
};