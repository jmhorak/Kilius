/**
 * Resource fetching module. Accepts a file name and pulls it from the
 *   client directory. Only reads, does not write.
 *
 * Author: Jeff Horak
 * Date: 7/11/12
 */

var Promise = require('modPromise').Promise,
    logging = require('modLogging'),
    options = require('modOptions'),
    fs      = require('fs');

/**
 * Determines the MIME type for a given resource (based on name of the resource)
 * @param resource {String} - Name of the resource
 * @return {*} - MIME type or null
 */
function getContentType(resource) {

  if (/\.css$/i.test(resource)) {
    return 'text/css';
  }

  if (/\.html?$/i.test(resource)) {
    return 'text/html';
  }

  if (/\.js$/i.test(resource)) {
    return 'text/javascript';
  }

  if (/\.ico$/i.test(resource)) {
    return 'image/x-icon';
  }

  if (/\.swf$/i.test(resource)) {
    return 'application/x-shockwave-flash';
  }

  return null;
}

/**
 * Fetch a resource from the file system
 * @param resource {String} Resource to fetch
 * @param client {String} Client
 * @return {Object} - a Promise
 */
exports.fetchResource = function(resource, client) {
  var promise = new Promise(),
      invalidFileStr = 'Missing or invalid file',
      invalidFileCode = 404,
      mimeType = getContentType(resource),
      loadPath;

  if (!mimeType) {

    // We are only serving files with pre-determined extensions
    promise.reject(invalidFileStr, invalidFileCode);
    logging.error({
      message: invalidFileStr,
      client: client,
      error: 'Requested file with non-white listed extension: ' + resource,
      code: invalidFileCode
    });

  } else {

    loadPath = options.clientRootFilePath + '/' + resource;

    // Requests should never try to access outside the content subdirectory
    //  This call will sanitize the path so we can analyze it
    fs.realpath(loadPath, null, function(err, path) {

      if (err) {

        // Item does not exist
        promise.reject(invalidFileStr, invalidFileCode);
        logging.error({
          message: invalidFileStr,
          client: client,
          error: err,
          code: invalidFileCode
        });

      } else if (path.indexOf(options.clientRootFilePath) !== 0) {

        // The resolved path does not have its root in our client file path
        promise.reject(invalidFileStr, invalidFileCode);
        logging.error({
          message: invalidFileStr,
          client: client,
          error: 'Attempt to request up the directory tree.',
          code: invalidFileCode
        });

      } else {

        fs.stat(path, function(err, stats) {

          if (err) {

            // Item does not exist
            promise.reject(invalidFileStr, invalidFileCode);
            logging.error({
              message: invalidFileStr,
              error: err,
              client: client,
              code: invalidFileCode
            });

            return;
          }

          if (!stats.isFile()) {

            // Item is not a file, only return files
            promise.reject(invalidFileStr, invalidFileCode);
            logging.error({
              message: invalidFileStr,
              error: 'Requested resource is not a file',
              client: client,
              code: invalidFileCode
            });

            return;
          }

          fs.readFile(path, function(err, fd) {
            var readFailMessage = 'Could not load resource',
                readFailCode = 503;

            if (err) {
              // Some server error occurred
              // 503 => Service temporarily unavailable
              promise.reject(readFailMessage, readFailCode);
              logging.error({
                message: readFailMessage,
                error: err,
                client: client,
                code: readFailCode
              });

              return;
            }

            // Resolve promise with the file data, stats, and MIME type
            promise.resolve(fd, stats, mimeType);

            // Log that a file was fetched
            logging.log({
              client: client,
              message: 'Served ' + resource
            });
          });
        });
      }
    });
  }

  return promise;
};