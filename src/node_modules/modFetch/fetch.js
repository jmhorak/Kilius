/**
 * Resource fetching module. Accepts a file name and pulls it from the
 *   client directory. Only reads, does not write.
 *
 * Author: Jeff Horak
 * Date: 7/11/12
 */

var Promise = require('modPromise').Promise,
    logging = require('modLogging'),
    options = require('modOptions'),
    domain  = require('domain'),
    fs      = require('fs'),
    Emitter = require('events').EventEmitter,

    invalidFileStr  = 'Missing or invalid file',
    invalidFileCode = 404;

/**
 * Determines the MIME type for a given resource (based on name of the resource)
 * @param resource {String} - Name of the resource
 * @return {*} - MIME type or null
 */
function getContentType(resource) {

  if (/\.css$/i.test(resource)) {
    return 'text/css';
  }

  if (/\.html?$/i.test(resource)) {
    return 'text/html';
  }

  if (/\.js$/i.test(resource)) {
    return 'text/javascript';
  }

  if (/\.ico$/i.test(resource)) {
    return 'image/x-icon';
  }

  if (/\.swf$/i.test(resource)) {
    return 'application/x-shockwave-flash';
  }

  if (/\.svg$/i.test(resource)) {
    return 'image/svg+xml';
  }

  if (/\.ttf$/i.test(resource)) {
    return 'application/octet-stream';
  }

  if (/\.woff$/i.test(resource)) {
    return 'font/woff';
  }

  if (/\.eot$/i.test(resource)) {
    return 'application/vnd.ms-fontobject';
  }

  if (/\.txt$/i.test(resource)) {
    return 'text/plain';
  }

  return null;
}

/**
 * Fetch a resource from the file system
 * @param resource {String} Resource to fetch
 * @param client {String} Client
 * @param modSince {Date} Last modified time of client cached file
 * @return {Object} - a Promise
 */
exports.fetchResource = function(resource, client, modSince) {
  var promise = new Promise(),
      emitter = new Emitter(),
      mimeType = getContentType(resource),
      loadPath,
      fetchDomain;

  if (!mimeType) {

    // We are only serving files with pre-determined extensions
    promise.reject(invalidFileStr, invalidFileCode);
    logging.error({
      message: invalidFileStr,
      client: client,
      error: 'Requested file with non-white listed extension: ' + resource,
      code: invalidFileCode
    });

  } else {

    loadPath = options.clientRootFilePath + '/' + resource;
    fetchDomain = domain.create();
    fetchDomain.add(emitter);

    fetchDomain.on('error', function(err) {

      // Item does not exist
      promise.reject(invalidFileStr, invalidFileCode);
      logging.error({
        message: invalidFileStr,
        client: client,
        error: err,
        code: invalidFileCode
      });

      // Clean up
      fetchDomain.dispose();

    });

    // Requests should never try to access outside the content subdirectory
    //  This call will sanitize the path so we can analyze it
    fs.realpath(loadPath, null, function(err, path) {

      if (err) {
        emitter.emit('error', err);
        return;
      }

      if (path.indexOf(options.clientRootFilePath) !== 0) {

        // The resolved path does not have its root in our client file path
        emitter.emit('error', 'Attempt to request up the directory tree.');
        return;

      }

      fs.stat(path, function(err, stats) {

        if (err) {

          // Item does not exist
          emitter.emit('error', err);
          return;
        }

        if (!stats.isFile()) {

          // Item is not a file, only return files
          emitter.emit('error', 'Requested resource is not a file');
          return;
        }

        if (modSince && stats.mtime.valueOf() === modSince.valueOf()) {
          // Use the cached version
          promise.resolve(true);

          logging.log({
            client: client,
            message: 'Use client cached ' + resource
          });

        } else {
          fs.readFile(path, function(err, fd) {
            var readFailMessage = 'Could not load resource',
                readFailCode = 503;

            if (err) {
              // Some server error occurred
              // 503 => Service temporarily unavailable
              promise.reject(readFailMessage, readFailCode);
              logging.error({
                message: readFailMessage,
                error: err,
                client: client,
                code: readFailCode
              });

              return;
            }

            // Resolve promise with the file data, stats, and MIME type
            promise.resolve(false, fd, stats, mimeType);

            // Log that a file was fetched
            logging.log({
              client: client,
              message: 'Served ' + resource
            });
          });
        }
      });
    });
  }

  return promise;
};