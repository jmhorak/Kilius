/**
 * Methods for request handling. This module handles requests and
 * creates responses
 *
 * Author: Jeff Horak
 * Date: 7/2/12
 */

var Promise     = require('modPromise').Promise,
    shorten     = require('modShorten'),
    resolve     = require('modResolve'),
    logging     = require('modLogging'),
    stats       = require('modStats'),
    options     = require('modOptions'),
    fileFetcher = require('modFetch'),
    url         = require('url'),
    queryString = require('querystring');

/**
 * Fetches a resource and returns it in a response
 * @param context {Object} The context for handling the request
 */
function serveResource(context) {
  var resource = context.resource,
      response = context.response,
      code = context.code,
      modSince = context.modSince,
      client = context.client;

  /**
   * Success callback when fetching a resource
   * @param fd       {Object} File data
   * @param stats    {Object} File information
   * @param mimeType {String} MIME type of the file
   */
  function sendResource(fd, stats, mimeType) {

    if (stats.mtime.valueOf() === modSince.valueOf()) {

      // Client has it cached, return 304
      response.writeHead(304);
      response.end();

    } else {

      response.writeHead(code || 200, {
        'Content-Type': mimeType,
        // Cache for one week
        'Cache-Control': 'public, max-age=604800',
        'Content-Length': +stats.size,
        'Last-Modified': stats.mtime.toUTCString()
      });

      response.end(fd);
    }
  }

  function sendErrorJSON(message, fetchCode) {

    message = message || 'Server error fetching file';

    // Couldn't fetch the error file for some reason
    response.writeHead(fetchCode, {
      'Content-Type': 'application/json'
    });

    response.end(JSON.stringify({
      message: message
    }));
  }


  fileFetcher.fetchResource(resource, client).then( sendResource,

      /**
       * Error callback when fetching a resource
       * @param message   {String} Returned error string
       * @param fetchCode {Number} Status code to return to the client
       */
      function(message, fetchCode) {

        fetchCode = fetchCode || 500;

        // Unless the original error code was 404 or 500
        if (code !== 404 && code !== 500) {

          if (fetchCode === 404) {
            // Fetch the 404.html
            fileFetcher.fetchResource('404.html', client).then( sendResource, sendErrorJSON);

          } else if (fetchCode === 500) {
            // Fetch the 500.html
            fileFetcher.fetchResource('500.html', client).then( sendResource, sendErrorJSON);

          } else {
            sendErrorJSON(message, fetchCode);
          }

        } else {
          sendErrorJSON(message, fetchCode);
        }
      }
  );
}

/**
 * Handle resolving a URL and creating the response
 * @param reqData
 */
exports.handleResolveURL = function(reqData) {

  var res = reqData.response,
      host = reqData.host;

  // Resolve the URL
  resolve.resolveURL({
    url: reqData.url.href,
    client: host,
    userAgent: reqData.ua

  }).then(

      function(destination) {

        // 307 => Temporary redirect
        // Link successfully resolved, redirect to longLink
        // Use 307 so browsers don't cache forwarded address.
        // We want to keep stats on hits
        res.writeHead(307, {
          'Location': destination
        });
        res.end();

      },

      function(message, code) {

        var resource = code === 500 ? '500.html' : '404.html';

        serveResource({
          resource: resource,
          code: code,
          response: res,
          client: host
        });
      }
  );
};

/**
 * Handle building user link history
 * @param reqData
 */
exports.handleStatsForUser = function(reqData) {
  var page = parseInt(queryString.parse(reqData.url.query).page, 10) || 0,
      res = reqData.response;

  stats.linksForUser({
    clientID: reqData.host,
    page: page
  }).then(

      /**
       * Success callback when building link history for a user
       * @param results - The history links for a user
       */
      function(results) {

        var history = [],
            jsonString,
            len = results.length,
            idx = 0;

        // Sanitize the return - only return specific values
        for (; idx < len; idx++) {
          history.push({
            longLink: results[idx].longLink,
            shortLink: results[idx].shortLink,
            hits: results[idx].hits,
            createDate: results[idx].createDate
          });
        }


        jsonString = JSON.stringify({ history: history });

        // Write the response
        res.writeHead(200, {
          'Content-Type': 'application/json',
          'Content-Length': +Buffer.byteLength(jsonString)
        });
        res.end(jsonString);
      },

      /**
       * Error callback when building link history for a user
       * @param message - Message to send to the client
       * @param code - Error code
       */
      function(message, code) {

        // Some error occurred, write the response
        message = message || 'Server error building user history';
        code = code || 500;

        res.writeHead(code, {
          'Content-Type': 'application/json'
        });

        res.end(JSON.stringify({
          message: message
        }));
      }
  );
};

/**
 * Handle fetching a resource and returning it
 * @param reqData
 */
exports.handleFetchResource = function(reqData) {
  serveResource({
    resource: reqData.resource,
    response: reqData.response,
    client: reqData.host,
    modSince: reqData.modSince
  });
};

/**
 * Handle a request for an unsupported action
 * @param reqData
 */
exports.handleUnsupportedRequest = function(reqData) {

  var res = reqData.response;

  logging.error({
    message: [reqData.verb, ' for ', reqData.path, ' not implemented'].join(''),
    code: 405
  });

  // 405 => Method not allowed
  res.writeHead(405);
  res.end();
};

/**
 * Handle shortening a URL and creating the response
 * @param reqData
 */
exports.createShortenedURL = function(reqData) {
  var res = reqData.response;

  shorten.shortenURL({
    url: reqData.data.url,
    client: reqData.host

  }).then(
      /**
       * Success callback when shortening the link
       * @param shortLink {String} - Shortened link
       * @param throttleUpdate {Number} - Number of links remaining until
       *                                  throttle limit is reached
       */
      function(shortLink, throttleUpdate) {

        // 201 => Created New Item
        res.writeHead(201, {
          'Content-Type': 'application/json',
          'Location': shortLink
        });

        res.end(JSON.stringify({
          throttle: throttleUpdate
        }));

      },

      /**
       * Failure callback when shortening the link
       * @param message {String} - Error message to return to the client
       * @param code {Number} - Error code
       */
      function(message, code) {

        // Some error occurred, write the response
        message = message || 'Server error while shortening URL';
        code = code || 500;

        res.writeHead(code, {
          'Content-Type': 'application/json'
        });

        res.end(JSON.stringify({
          message: message
        }));
      }
  );
};