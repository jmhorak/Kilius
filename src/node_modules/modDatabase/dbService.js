/**
 * Database layer for Kili.us server
 *
 * Author: Jeff Horak
 * Date: 5/18/12
 */

var m = require('mongodb'),
    p = require('modPromise'),
    mongo = null;

function log(collection, payload, callback) {
  var promise = new p.Promise();

  // Set the date if not already set
  payload.date = payload.date ? payload.date : new Date();

  collection.insert(payload, { safe: true }, function(err, result) {
    if (err) {
      promise.reject(err);
    } else {
      promise.resolve(result);
    }
  });

  return promise;
}

function initializeCollection(name, createOptions) {
  var promise = new p.Promise();

  mongo.collection( name, {safe: true}, function(err, result) {
    if (err) {

      // Collection does not exist, create it
      mongo.createCollection( name, createOptions.options, function(err, collection) {

        if (err) {
          promise.reject(err);
        } else {

          // Created the collection, does it need an initial value set?
          if (createOptions.value) {

            collection.insert( createOptions.value, { safe: true }, function(err)  {

              if (err) {
                promise.reject(err);
              } else {
                // Successfully added the initial values
                promise.resolve();
              }

            });

          } else {
          // No initial value required
            promise.resolve();
          }
        }
      });

    } else {
    // Collection already created
      promise.resolve();
    }
  });

  return promise;
};

exports.initDatabase = function(database) {
  var promise = new p.Promise(),
      initCounter,
      initLinks,
      initErrLog,
      initActLog;

  // Connect to the mongo database
  mongo = new m.Db(database, new m.Server('localhost', 27017, {}));

  mongo.open(function(err, result) {
    var mb = 1048576;

    if (err) {
      promise.reject(err);
    } else {

      // Create the counter collection and start the links counter at 0
      initCounter = initializeCollection('counter', {
        options: { safe: true },
        value: {tbl: 'links', c: 0}
      });

      // Create the links collection
      initLinks = initializeCollection('links', {
        options: { safe: true }
      });

      // Create the err log collection, cap it at 10 MB
      initErrLog = initializeCollection('errLog', {
        options: { safe: true, capped: true, size: mb*10 }
      });

      // Create the activity log collection, cap it at 50 MB
      initActLog = initializeCollection('actLog', {
        options: { safe: true, capped: true, size: mb*50 }
      });

      // Wait for all operations to finish
      p.Promise.when(initCounter, initLinks, initErrLog, initActLog).then(function() {

        // Successfully finished, resolve the promise and pass any arguments along
        promise.resolve(mongo);

      }, function(err) {

        // Failed, reject the promise and pass any arguments along
        promise.reject(err);

      });

    }
  });

  return promise;
};

exports.close = function() {
  mongo.close();
}

exports.logError = function(payload) {
  // Write the payload to the errLog database
  return log(mongo.collection('errLog'), payload);
}

exports.logActivity = function(payload) {
  // Write the payload to the actLog database
  return log(mongo.collection('actLog'), payload);
}

exports.addNewLinkHit = function(linkID, hitInfo) {
  var links = mongo.collection('links'),
      promise = new p.Promise();

  links.findAndModify({linkID: linkID}, [], { $push: { hits: hitInfo }}, {safe: true, new: true},
      function(err, result) {

        if (err) {
          // Database error
          promise.reject({
            logMessage: 'Database error updating resolved link for ID ' + linkID,
            error: err,
            code: 500,
            failedPayload: hitInfo
          });

        } else if (result && result.longLink) {
          // The long link was found
          promise.resolve(result.longLink);

        } else {
          // The long link was not found
          promise.reject({
            logMessage: ['Long link for id ', linkID, ' not found'].join(''),
            code: 404
          });

        }
      }
  );

  return promise;
}

exports.getNextLinkID = function() {
  var counter = mongo.collection('counter'),
      promise = new p.Promise();

  counter.findAndModify({tbl: 'links'}, [], {$inc: {c: 1}}, {safe: true, new: true },
      function(err, result) {

        if (err) {
          // Database error
          promise.reject({
            logMessage: 'Database error incrementing links counter',
            error: err,
            code: 500
          });

        } else if (result && result.c && typeof result.c === 'number') {
          // Success, resolve the promise
          promise.resolve(result.c);

        } else {
          // Bad data returned from the database
          promise.reject({
            logMessage: 'Incrementing counter link did not return a number',
            error: result,
            code: 500
          });
        }
      }
  );

  return promise;
}

exports.insertLink = function(linkPayload) {
  var links = mongo.collection('links'),
      promise = new p.Promise();

  /*if (!linkPayload.clientID) {
    linkPayload.clientID = 'Unknown';
  }

  if (!linkPayload.linkID) {
    exports.logError({
      logMessage: 'Missing linkID when trying to insert a link',
      code: 500
    }, function() {
      callback(null, null); // TODO FIX
    });
    return;
  }

  if (!linkPayload.longLink) {
    exports.logError({
      logMessage: 'Missing the long link when trying to insert a link',
      code: 500
    }, function() {
      callback(null, null); // TODO FIX
    });
  }

  if (!linkPayload.longLink) {
    exports.logError({
      logMessage: 'Missing the short link when trying to insert a link',
      code: 500
    }, function() {
      callback(null, null); // TODO FIX
    });
  }

  if (!linkPayload.createDate) {
    linkPayload.createDate = new Date;
  }

  if (!linkPayload.hits) {
    linkPayload.hits = [];
  }*/

  links.insert(linkPayload, { safe: true },
    function(err, result) {

      if (err) {
        /*exports.logError({
          failedPayload: linkPayload
        }, function() {
          callback('Oops. We\'ve encountered a database error and were unable to process your request.', null);
        })*/

        // Database error
        promise.reject({
          logMessage: 'Database error inserting into links database',
          error: err,
          code: 500
        });

      } else {
        promise.resolve(true);
      }
    }
  )

  return promise;
}

exports.linksForUser = function(options) {
  var links = mongo.collection('links'),
      promise = new p.Promise(),
      pageSize = options.pageSize,
      skipTo = options.page || 0,
      clientID = options.clientID;

  links.find({ clientID: clientID }, {'longLink': 1, 'shortLink': 1, 'hits': 1, 'createDate': 1})
      .sort('createDate', 'desc', null)
      .limit(pageSize, null)
      .skip(pageSize*skipTo, null)
      .toArray(function(err, results) {

        if (err) {
          promise.reject({
            logMessage: 'Error building stats for user ' + clientID,
            error: err,
            code: 500
          });
        } else {
          promise.resolve(results);
        }

      });

  return promise;
}

