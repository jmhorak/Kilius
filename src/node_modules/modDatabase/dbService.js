/**
 * Database layer for Kili.us server
 *
 * Author: Jeff Horak
 * Date: 5/18/12
 */

var m = require('mongodb'),
    Promise = require('modPromise').Promise,
    options = require('modOptions'),
    isAuthenticatedSession = false,
    mongo = null;

/**
 * Returns a function binding the promise to a set of results
 * @param promise - Promise to fulfill
 * @return {Function}
 */
function fulfillPromise(promise) {

  return function(err, results) {
    if (err) {
      promise.reject(err);
    } else {
      promise.resolve(results);
    }
  };
}

/**
 * Write a log entry to the database
 * @param collection - The collection to write to
 * @param payload - The log payload
 * @return {*} - Promise
 */
function log(collection, payload) {
  var promise = new Promise();

  // Set the date if not already set
  payload.date = payload.date ? payload.date : new Date();

  collection.insert(payload, { safe: true }, fulfillPromise(promise) );

  return promise;
}

/**
 * Fetch the specified portion of the given log
 * @param collection - The collection to read
 * @param page - The page to fetch
 * @param pageSize - Size of a page
 * @return {*}
 */
function fetchLog(collection, page, pageSize) {
  var promise = new Promise();

  collection
      .find()
      .sort('date', 'desc', null)
      .limit(pageSize, null)
      .skip(pageSize*page, null)
      .toArray(fulfillPromise(promise));

  return promise;
}

/**
 * Fetch the number of records in the given collection
 * @param collection - The collection to search
 * @return {*} - Promise
 */
function tableSize(collection) {
  var promise = new Promise();

  collection.count(fulfillPromise(promise));

  return promise;
}

/**
 * Initializes a collection with the given name and options
 * @param name - The collection to initialize
 * @param createOptions - Options to pass to mongo when creating the collection
 * @return {*} - Promise
 */
function initializeCollection(name, createOptions) {
  var promise = new Promise();

  mongo.collection( name, {safe: true}, function(err, result) {
    if (err) {

      // Collection does not exist, create it
      mongo.createCollection( name, createOptions.options, function(err, collection) {

        if (err) {
          promise.reject(err);
        } else {

          // Created the collection, does it need an initial value set?
          if (createOptions.value) {

            collection.insert( createOptions.value, { safe: true }, fulfillPromise(promise));

          } else {
          // No initial value required
            promise.resolve();
          }
        }
      });

    } else {
    // Collection already created
      promise.resolve();
    }
  });

  return promise;
}

/**
 * Initializes a collection and then adds an index
 * @param collectionName - The collection name
 * @param createOptions - Options to use when creating the collection
 * @param field - The field to index
 * @param indexOptions - Options for creating the index
 * @return {*} - Promise
 */
function initializeCollectionWithIndex(collectionName, createOptions, field, indexOptions) {
  var promise = new Promise();

  initializeCollection(collectionName, createOptions).then(

      function() {

        var indexField = {};
        indexField[field] = 1;
        // Initialized, now create the index
        mongo.ensureIndex(collectionName, indexField, indexOptions, fulfillPromise(promise));
      },

      function(err) {
        // There was an error initializing the collection
        promise.reject(err);
      }
  );

  return promise;
}

/**
 * Authenticates the server with the database if necessary
 * @return {*} - Promise
 */
function authenticateToDatabase() {
  var promise = new Promise(),
      username = options.databaseUser,
      password = options.databasePassword;

  // If a username is provided, authenticate
  if (username) {

    mongo.authenticate(username, password, function(err, authenticated) {

      if (err) {
        promise.reject(err);

      } else if (!authenticated) {
        promise.reject('could not authenticate user');

      } else {
        isAuthenticatedSession = true;
        promise.resolve();
      }
    });

  } else {
    // No username, no authentication required
    console.log('No authentication to the database made, make sure that firewall is air-tight!');
    promise.resolve();
  }

  return promise;
}

/**
 * Initializes the database creating collections if needed
 * @return {*} - Promise
 */
exports.initDatabase = function() {
  var promise = new Promise(),
      database = options.database,
      host = options.databaseHost,
      port = options.databasePort,
      user = options.databaseUser,
      pass = options.databasePassword,
      initCounter,
      initLinks,
      initErrLog,
      initActLog,
      initBlackList;

  // Connect to the mongo database
  mongo = new m.Db(database, new m.Server(host, port, { poolSize: 10 }));

  mongo.open(function(err, result) {
    var mb = 1048576;

    if (err) {
      promise.reject(err);
    } else {

      authenticateToDatabase().then(

          // Successfully authenticated
          function() {
            // Create the counter collection and start the links counter at 0
            initCounter = initializeCollection('counter', {
              options: { safe: true },
              value: {tbl: 'links', c: 0}
            });

            // Create the links collection
            initLinks = initializeCollection('links', {
              options: { safe: true }
            });

            // Create the err log collection, cap it at 10 MB
            initErrLog = initializeCollection('errLog', {
              options: { safe: true, capped: true, size: mb*10 }
            });

            // Create the activity log collection, cap it at 50 MB
            initActLog = initializeCollection('actLog', {
              options: { safe: true, capped: true, size: mb*50 }
            });

            initBlackList = initializeCollectionWithIndex(
                'blacklist',
                { options: { safe: true } },
                'clientID',
                { unique:true, dropDups:true, safe:true }
            );

            // Wait for all operations to finish
            Promise.when(initCounter, initLinks, initErrLog, initActLog, initBlackList).then(

                // Successfully finished, resolve the promise and pass any arguments along
                function() {
                  promise.resolve();
                },

                // Failed, reject the promise and pass any arguments along
                function(err) {
                  promise.reject(err);
                }
            );
          },

          // Failed authenticating to the database
          function(message) {
            promise.reject(message);
          }
      );
    }
  });

  return promise;
};

/**
 * CLose the database connection
 */
exports.close = function() {
  var promise = new Promise();

  if (isAuthenticatedSession) {
    mongo.logout(function(err, loggedOut) {

      if (err) {
        promise.reject('Could not log out');
      }

      mongo.close(true, function(err) {
        if (err) {
          promise.reject('Could not close database: ' + JSON.stringify(err));
        } else {
          promise.resolve();
        }
      });
    });

  } else {
    mongo.close(true, function(err) {
      if (err) {
        promise.reject('Could not close database: ' + JSON.stringify(err));
      }
    });
  }

  return promise;
};

/**
 * Log an error to the database
 * @param payload - The data to log
 * @return {*} - Promise
 */
exports.logError = function(payload) {

  var message = payload ? payload.message : null,
      red = '\u001b[31m',
      reset = '\u001b[0m';

  if (message) {
    console.error(red + message + reset);
  }

  // Write the payload to the errLog database
  return log(mongo.collection('errLog'), payload);
};

/**
 * Fetch a portion of the error log
 * @param page - The page to return
 * @param pageSize - The size of a page
 * @return {*} - Promise
 */
exports.fetchError = function(page, pageSize) {
  return fetchLog(mongo.collection('errLog'), page, pageSize);
};

/**
 * Returns the number of entries in the error log
 * @return {*} - Promise
 */
exports.errorSize = function() {
  return tableSize(mongo.collection('errLog'));
};

/**
 * Log activity to the database
 * @param payload - The data to log
 * @return {*} - Promise
 */
exports.logActivity = function(payload) {
  // Write the payload to the actLog database
  return log(mongo.collection('actLog'), payload);
};

/**
 * Fetch a portion of the activity log
 * @param page - The page to return
 * @param pageSize - The size of a page
 * @return {*} - Promise
 */
exports.fetchLog = function(page, pageSize) {
  return fetchLog(mongo.collection('actLog'), page, pageSize);
};

/**
 * Returns the number of entries in the activity log
 * @return {*} - Promise
 */
exports.logSize = function() {
  return tableSize(mongo.collection('actLog'));
};

/**
 * Adds a new link hit to the link info for the given link ID
 * @param linkID - The link receiving the hit
 * @param hitInfo - Information about the hit (date/time, user agent, etc)
 * @return {*} - Promise
 */
exports.addNewLinkHit = function(linkID, hitInfo) {
  var links = mongo.collection('links'),
      promise = new Promise();

  links.findAndModify({linkID: linkID}, [], { $push: { hits: hitInfo }}, {safe: true, "new": true},
      function(err, result) {

        if (err) {
          // Database error
          promise.reject({
            message: 'Database error updating resolved link for ID ' + linkID,
            error: err,
            code: 500
          });

        } else if (result && result.longLink) {
          // The long link was found
          promise.resolve(result.longLink);

        } else {
          // The long link was not found
          promise.reject({
            message: 'Missing or invalid URI',
            error: ['Long link for id ', linkID, ' not found'].join(''),
            code: 404
          });

        }
      }
  );

  return promise;
};

/**
 * Fetches the next available ID for a shortened link
 * @return {*} - Promise
 */
exports.getNextLinkID = function() {
  var counter = mongo.collection('counter'),
      promise = new Promise();

  // Atomically fetch the links counter and increment it by one. The returned
  //   value will be used in generating a new link
  counter.findAndModify({tbl: 'links'}, [], {$inc: {c: 1}}, {safe: true, "new": true },
      function(err, result) {

        if (err) {
          // Database error
          promise.reject({
            message: 'Database error incrementing links counter',
            error: err,
            code: 500
          });

        } else if (result && result.c && typeof result.c === 'number') {
          // Success, resolve the promise
          promise.resolve(result.c);

        } else {
          // Bad data returned from the database
          promise.reject({
            message: 'Incrementing counter link did not return a number',
            error: result,
            code: 500
          });
        }
      }
  );

  return promise;
};

/**
 * Inserts a new link item into the database
 * @param linkPayload - The link to add to the database
 * @return {*} - Promise
 */
exports.insertLink = function(linkPayload) {
  var links = mongo.collection('links'),
      promise = new Promise();

  links.insert(linkPayload, { safe: true },
    function(err, result) {

      if (err) {

        // Database error
        promise.reject({
          message: 'Database error inserting into links database',
          error: err,
          code: 500
        });

      } else {
        promise.resolve(true);
      }
    }
  );

  return promise;
};

/**
 * Fetches a slice of the links created by a given user
 * @param options - Options to use in the query
 * @return {*} - Promise
 */
exports.linksForUser = function(options) {
  var links = mongo.collection('links'),
      promise = new Promise(),
      pageSize = options.pageSize,
      skipTo = options.page || 0,
      clientID = options.clientID;

  links.find({ clientID: clientID }, {'longLink': 1, 'shortLink': 1, 'hits': 1, 'createDate': 1})
      .sort('createDate', 'desc', null)
      .limit(pageSize, null)
      .skip(pageSize*skipTo, null)
      .toArray(function(err, results) {

        if (err) {
          promise.reject({
            message: 'Error building stats for user ' + clientID,
            error: err,
            code: 500
          });
        } else {
          promise.resolve(results);
        }

      });

  return promise;
};

/**
 * Creates and returns a populated a list of blacklisted clients
 * @return {*} - Promise
 */
exports.populateBlacklist = function() {
  var blacklist = mongo.collection('blacklist'),
      promise = new Promise();

  // Fetch the entire list and return it
  blacklist.find().toArray(function(err, list) {

    if (err) {
      promise.reject({
        message: 'Error populating blacklist',
        error: err,
        code: 500
      });

    } else {
      promise.resolve(list || []);
    }

  });

  return promise;
};

/**
 * Adds a client to the blacklist database
 * @param client - The client to add
 * @return {*} - Promise
 */
exports.addToBlacklist = function(client) {
  var blacklist = mongo.collection('blacklist'),
      promise = new Promise();

  blacklist.insert({ clientID: client }, { safe: true },
      function(err, result) {

        if (err) {
          promise.reject({
            message: 'Error adding client ' + client + ' to the blacklist',
            error: err,
            code: 500
          });

        } else {
          promise.resolve();
        }
      }
  );

  return promise;
};

/**
 * Removes a client from the blacklist database
 * @param client - The client to remove
 * @return {*} - Promise
 */
exports.removeFromBlacklist = function(client) {
  var blacklist = mongo.collection('blacklist'),
      promise = new Promise();

  blacklist.findAndRemove({ clientID: client }, [], { safe: true }, function(err) {

    if (err) {
      promise.reject({
        message: 'Error removing client ' + client + ' from the blacklist',
        error: err,
        code: 500
      });
    } else {
      promise.resolve();
    }

  });

  return promise;
};